Locality Sensitive Hashing(LSH)
======

## Introduction  
Locality Sensitive Hashing(LSH) is a number of hash functions that similar items map to the same 'bucket' with a higher possibility. Locality sensitive hashing can be used in approximate nearest neighbor search or high dimension data indexing.   
LSH requires a large amount of calculation, and building a LSH index for a large amount of data may take a long time. However, LSH is very suitable for dataflow engine acceleration, because the length of the loop is fixed and the calculation is uncorrelated.  

## Algorithms  
LSH function has the following characters to guarantee the 'locality'  
* 1. if d(p1, p2) < R, then h(p1)=h(p2) with possibility at least Pr1  
* 2. if d(p1, p2) > R, then h(p1)=h(p2) with possibility at most Pr2  
* 3. Pr1 > Pr2  

In this dataflow version of LSH, we implement p-stable LSH, which is a random hyperplane and the hash value is the distance between point and hyperplane.  
For more details, please visit  
* 1. [LSH introduction](https://en.wikipedia.org/wiki/Locality-sensitive_hashing)  
* 2. [p-stable LSH](http://web.mit.edu/andoni/www/LSH/)  

##Implementation
There are three kinds of function in LSH  
* 1. h(x) represents a random hyperplane function.  
* 2. Cascade h(x) to get g(x)={h1(x), h2(x)... hk(x)}. The relationship between h function is 'and' to improve accuracy.  
* 3. Repeat g(x) function to get l(x)={g1(x), g2(x)... gl(x)}. The relationship between g function is 'or' to improve recall rate.  

All these function have corresponding implementation in DFE  
* 1. h(x) is represented by a dataflow in kernel  
* 2. g(x) is represented by one LSHKernel  
* 3. l(x) is represented by repeating several LSHKernel in one LSHManager  

Each function is completely independent with each other, each data point is independent with each other, so LSH can be perfectly acclerated by dataflow engine without any loop dependencies.  

For details about implementation and performance analysis, please see [LSH.pdf](LSH.pdf)  

## Notice  
1. This implementation is just a simple version of p-stable LSH, in some other versions, LSH also needs a rehash procedure or other kernel function. You can just define another kernel hashing function and combine it with our manager.  
2. We use 128bits to represent the hash value generated by LSH, in some cases when the output dimension is high and max hash value is large, it may overflow and lead to collision. In these cases we have to increase the number of bits or use a rehash function.